# LeetCodeAlgorithms

## 数组

> 时刻关注数组下标是什么，其次关注里面的值
> 因为内存连续，所以随机访问很快，缺点是插入删除很慢，时间复杂度为O(N)

### 数据结构

* 一块连续的内存地址
* 寻址公式 1纬 loc = init_loc + index(数组下标) * data_size（数据大小int 4个字节）
* 二维：int[m][n] loc[i][j] = init_loc + (i * n（一唯长度） +j) * data_size（数据大小int 4个字节）

### 妙用

* 统计14亿各个年龄的总人数 巧妙利用数组下标为年龄，值为总数
* 统计某个字符的出现次数，也是巧妙利用下标

### 高频考点排序

* 排序
    * 排序数字
        * 插入排序 把一个个无序的数列插入一个有序的数列中，参考打扑克 时间复杂度O(n2)
        * 希尔排序 性能同插入，是插入排序的改进版希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。
    * 排序对象 实现Comparable接口 重写compareTo方法即可
* 移除元素
  > 巧妙采用两个下标，一个记录当前位置，一个记录剔除后的位置

## 链表

### 和数组区别

1.和数组的操作有哪些不一样，插入有三步骤，数组要进行后面元素后移 
2.数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。
3.链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。 
4.数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out ofmemory）”。如果声明的数组过小，则可能出现不够用的情况。 5.动态扩容：数组需再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容。

### 考点

* 链表反转 1、采用递归 从后向前 2、采用循环 从前往后
* 2个链表相加
  > 三个参数 node node a（进位）

>

## 队列

## 栈

### 金典应用

* 检查开闭符号